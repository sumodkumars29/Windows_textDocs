findstr Regex Cheat Sheet (Windows CMD)

1ï¸âƒ£ Basic Syntax

	findstr [options] "pattern" [file(s)]

Options: /i, /r, /v, /x, /s, etc.
Pattern: regex (default) or literal if /l or /c: used
Files: one or more files, wildcards allowed (*.log)
Pipe input: can accept command | findstr ...


2ï¸âƒ£ Anchors

Symbol	Meaning		Example
^		Start of line	findstr /r "^START" server.txt â†’ lines beginning with START
$		End of line	findstr /r "successfully$" server.txt â†’ lines ending with successfully

Quirk: $ also matches EOF even if the last line has no newline. /x does not.


3ï¸âƒ£ Wildcards and Repetition
Symbol	Meaning										Example
.		Any single character							findstr /r "t.st" file.txt â†’ matches test, tast, etc.
*		Repeat previous character zero or more times	findstr /r "o*" â†’ zero or more os;  (for â€œany charsâ€ use .*)

Important: * repeats only the previous char, not the whole expression.

âœ… Example: match anything after START

	findstr /r "^START.*" server.txt


4ï¸âƒ£ Character Classes
Pattern		Meaning					Example
[abc]		Match any one char in set	[Ee]rror â†’ matches Error or error
[^abc]		Match any char not in set	[^0-9] â†’ any non-digit
[a-zA-Z0-9]	Letters and digits			[0-9]* â†’ zero or more digits

Quirk: ranges like [a-z] are literal ASCII ranges; no Unicode matching.


5ï¸âƒ£ Literal vs Regex

Literal search: 	/l or /c:"pattern"

Regex search: 	/r (default)

Example literal search with special chars:

	findstr /l "[INFO]" server.txt

	Matches exactly [INFO], not â€œany char in bracketsâ€.

Example regex:

	findstr /r "^\[INFO\].*successfully$" server.txt

	Matches lines starting with [INFO] and ending with successfully


6ï¸âƒ£ Multi-word Patterns

Spaces separate different search strings unless /c: is used

	findstr "Server started" server.txt

	Matches lines containing Server OR started, not both

	findstr /c:"Server started" server.txt

	Matches lines containing the exact phrase


7ï¸âƒ£ Alternation (OR)

| does NOT work in findstr

To simulate OR, pipe multiple findstr commands:

	findstr /i "ERROR" server.log | findstr /i "TIMEOUT"


To exclude multiple words:

	findstr /vi "DEBUG" server.txt | findstr /vi "INFO"

8ï¸âƒ£ Common Anchored Examples
Goal											Command
Match lines starting with [WARNING]				findstr /r "^\[WARNING\]" server.txt
Match lines ending with successfully					findstr /r "successfully$" server.txt
Match [INFO] lines containing Server					findstr /r "^\[INFO\].*Server" server.txt
Match lines that are exactly START (even at EOF)		findstr /r "^START$" server.txt

9ï¸âƒ£ Special Quirks
Issue					Explanation									Solution
/x fails on last line			/x expects line to end with CRLF					Use /r "^pattern$" or append newline
`						` alternation ignored							findstr doesnâ€™t support OR
* behavior				Only repeats previous char, not â€œany stringâ€		Use .* for any number of any chars
Spaces in search			Treated as multiple patterns					Use /c:"phrase with spaces"

ğŸ”Ÿ Recommended Switches with Regex
Switch		When to Use
/r			Regex matching (default), needed for ^, $, . and *
/i			Case-insensitive
/v			Invert match (exclude lines)
/n			Show line numbers
/c:"pattern"	Search literal phrase with spaces or special chars
/s			Search recursively in subfolders
/x			Exact line match (beware of EOF issues)

1ï¸âƒ£1ï¸âƒ£ Example Full Pipelines
Exclude DEBUG and INFO, number lines
	findstr /vi "DEBUG" server.txt | findstr /vi "INFO" | findstr /n "."

Match [WARNING] or [ERROR] lines, ignore case, recursive
	findstr /s /i /r "^\[WARNING\].* ^\[ERROR\].*" *.log


	Note: you need two separate findstr commands or a literal list file because | wonâ€™t work.

Match multi-word phrase exactly
	findstr /c:"Server started successfully" server.txt



ğŸ—ºï¸ Findstr Switch Interaction Map

Switch		Works With Regex?			Works With /x (Exact)?					Case-insensitive?			EOF Last Line						CRLF Line Endings				Notes / Gotchas
/r			âœ… Yes						âš ï¸ Only affects interpretation of regex		âŒ						âœ…								âœ…								Enables regex mode, allows ^, $, . and *. Default behavior.
/i			âœ… Works with regex			âœ… Works with /x							âœ… Ignores letter case		âœ…								âœ…								Only affects letters, not spaces, special chars, or CRLF.
/x			âš ï¸ Can combine with /r		âœ… Matches entire line literally				âœ… Works if /i added		âŒ Fails if last line has no newline	âœ… Requires CRLF to count line		Very literal, line must end with \n to match; EOF without newline breaks it.
/l			âŒ Ignores regex				âœ… Works with /x							âœ… Works with /i			âœ…								âœ…								Treats pattern literally. Best for special chars.
/c:"string"	âŒ Ignores regex				âœ… Works with /x							âœ… Works with /i			âœ…								âœ…								Treats multi-word phrases literally; spaces included.
/v			âœ… Works	âœ… Works		âœ… Works with /i							âœ…						âœ…								âœ…								Inverts matches; depends on actual pattern match â€” fails if regex is misused
/n			âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Only prints line numbers, doesnâ€™t affect matches.
/s			âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Searches subdirectories; works with wildcards.
/m			âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Only prints filenames containing match, ignores actual line content.
/o			âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Prefixes character offset of match. Useful with /r or /i.
/p			âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Skips non-printable files; safe for directories with binaries.
/f:file		âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Reads list of files from another file.
/g:file		âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Reads list of patterns from another file.
/d:dirlist		âœ… Works	âœ… Works		âœ… Works								âœ…						âœ…								âœ…								Searches multiple directories (semicolon-separated).


âš¡ Key Interaction Notes

EOF vs /x
	/x fails on last line if file has no newline (EOF).
	Use /r "^pattern$" to match safely even at EOF.

CRLF vs /x
	Windows lines end with CRLF (\r\n).
	/x expects the line to terminate properly. Extra characters (\r) can break matches.

Regex quirks
	. â†’ any single character
	* â†’ repeats previous character, not â€œany stringâ€
	Character classes [abc] are supported
	| alternaion does not work â†’ use pipes instead

Literal vs Regex
	/l disables regex, treats everything literally
	/c:"multi word" forces literal string, spaces included
	Case-insensitive /i
	Only affects letters
	Works with /r, /x, /l, /c:

Excluding multiple patterns
	/v inverts matches for a single pattern only
	To exclude multiple words: chain multiple findstr /v commands

âœ… Practical Advice

	Use /r "^pattern$" instead of /x for last-line matching.
	Always use /c: for multi-word or special-character patterns.
	Donâ€™t rely on | for OR â€” chain findstr commands.
	Remember /i only affects letters â€” numbers and symbols remain literal.
	EOF lines without newline break /x â€” append a newline or use regex anchors.

This table essentially gives you a predictive map: before you type any findstr command, you can check:

	Are you using regex or literal? (/r vs /l)
	Do you care about exact line match? (/x)
	Is your last line at EOF without a newline?
	Do you need case-insensitive? (/i)
	Are you excluding multiple patterns? (/v)

With this, you can anticipate almost every common gotcha in findstr.
