:: 1) What SETLOCAL actually does (plain English)

	:: SETLOCAL creates a new local environment block for the running batch file (or for the current call frame).
	:: Any environment changes after SETLOCAL (new variables, PATH edits, PROMPT, enabling/disabling extension features, etc.) are local to that block.
	:: When ENDLOCAL runs, the environment is restored to what it was before the matching SETLOCAL. In effect, SETLOCAL saves a snapshot; ENDLOCAL restores it.
	:: Key consequence: SETLOCAL prevents environment pollution — good when your script mustn’t leave behind changed variables.


:: 2) Nesting and implied ENDLOCAL

	:: SETLOCAL can be nested. Each SETLOCAL pushes another snapshot. Each ENDLOCAL pops one snapshot.
	:: If the batch file exits (falls off the end), any outstanding SETLOCAL are implicitly ended (CMD executes implied ENDLOCAL for each).
	:: ENDLOCAL without a matching SETLOCAL does nothing harmful but is meaningless.

:: 3) Interaction with Command Extensions and Delayed Expansion

	:: When Command Extensions are enabled (/E:ON or default on modern Windows) SETLOCAL accepts two optional arguments:
	:: SETLOCAL ENABLEEXTENSIONS / DISABLEEXTENSIONS — enable/disable command processor extensions for the local block.
	:: SETLOCAL ENABLEDELAYEDEXPANSION / DISABLEDELAYEDEXPANSION — enable/disable delayed expansion (the !VAR! form) locally.

	:: Important nuance:
	:: These local settings override the global CMD switches for the duration of the local block only. When ENDLOCAL restores the environment, the prior setting (global or parent) returns.

	:: Example:
		@echo off
		echo Global delayed expansion: %^V%   (example)
		SETLOCAL ENABLEDELAYEDEXPANSION
		:: now !VAR! will work inside this SETLOCAL block
		ENDLOCAL
	
	:: (That %^V% above is an example placeholder — ignore.)
	
:: 4) ERRORLEVEL behavior and the detection trick

	:: Historically, older CMD versions did not set ERRORLEVEL after SETLOCAL. Newer versions set it if you pass arguments.
	:: SETLOCAL will set ERRORLEVEL to 0 if one of the two valid arguments (ENABLEEXTENSIONS / DISABLEEXTENSIONS) is given and to non-zero otherwise (per the help text).
	:: The help suggests a technique to test whether extensions are available by first setting ERRORLEVEL to something non-zero, then calling SETLOCAL ENABLEEXTENSIONS and checking IF ERRORLEVEL 1 to tell if SETLOCAL changed ERRORLEVEL back to zero.	
	
	:: Example:
		VERIFY OTHER 2>nul
		SETLOCAL ENABLEEXTENSIONS
		IF ERRORLEVEL 1 echo Unable to enable extensions
	
		:: The VERIFY OTHER intentionally sets a non-zero ERRORLEVEL; 
		:: SETLOCAL ENABLEEXTENSIONS will set ERRORLEVEL to 0 on systems that support it 
		:: — so if it didn't, IF ERRORLEVEL 1 fires.
	
:: 5) Variable scope, expansion order, and the biggest gotcha

	:: This is the critical area that trips people: 
	:: percent expansion is done when the command line is parsed, not at execution time; 
	:: delayed expansion (!VAR!) is evaluated at execution time.	
	
	:: Example of the gotcha:
		@echo off
		SETLOCAL
		set VAR=before
		echo %VAR%
		set VAR=after
		echo %VAR%
		ENDLOCAL	
	
	:: That behaves as expected. 
	:: The tricky case is when you try to ENDLOCAL and then set an outer variable using an inner variable:	

	:: Example:	
		@echo off
		set OUT=initial
		SETLOCAL
		set OUT=inner
		ENDLOCAL
		echo OUT=%OUT%

	:: Surprise: OUT will still be initial. Why? 
	:: Because the set OUT=inner happened in the local environment and ...
	:: ENDLOCAL restored OUT to its previous value.
	:: Common need: pass a variable value created inside SETLOCAL back to caller
	:: A common workaround does not work as you’d naively write it because of parsing order:

	:: Example:
		:: WRONG: won't work
		SETLOCAL
		set LOCALVAR=hello
		ENDLOCAL & set OUTER=%LOCALVAR%

	::This fails because %LOCALVAR% is expanded before the ENDLOCAL runs — so it expands to the outer (old) value (or empty), not the inner one.

	:: Reliable workarounds

	:: 1) Use CALL to defer expansion (simple and common):

	:: Example:
		@echo off
		set OUT=
		SETLOCAL
		set LOCALVAR=hello world
		ENDLOCAL & call set "OUT=%%LOCALVAR%%"
		echo OUT=%OUT%

	:: Why it works: 
	::	Call causes a second parse run where %%LOCALVAR%% becomes %LOCALVAR% and 
	::  expansion happens after ENDLOCAL executed. This is the most straightforward pattern.

	:: 2) Use for /f with cmd /c echo (useful when value contains special characters/newlines carefully):

	:: Example:
		@echo off
		SETLOCAL
		set "LOCALVAR=some ^& weird % value"
		for /f "delims=" %%A in ('echo %LOCALVAR%') do (
			ENDLOCAL
			set "OUT=%%A"
		)
		echo OUT=%OUT%

	:: This preserves many characters (but be careful with newlines and certain characters). 
	:: Common in legacy scripts.	
	
	:: 3) Write to a temporary file (robust for large/complex data):

	:: Example:	
		SETLOCAL
		echo %LOCALVAR%>"%temp%\myvar.tmp"
		ENDLOCAL
		set /p OUT=<"%temp%\myvar.tmp"
		del "%temp%\myvar.tmp"	
	
	:: Recommendation: use the call set "OUT=%%LOCALVAR%%" pattern for most simple cases.
	
	
:: 6) Delayed expansion and loops — common interplay

	:: In loops (for, if blocks), percent expansion of variables inside the block is done when the line is parsed — 
	:: so you often need delayed expansion to get the variable's updated value during loop iterations.	
	
	:: Example:
		SETLOCAL ENABLEDELAYEDEXPANSION
		set i=0
		for %%F in (a b c) do (
		set /a i+=1
		echo Iteration !i!: %%F
		)
		ENDLOCAL
	
	:: Without !i! and ENABLEDELAYEDEXPANSION, you'd see the initial i value every loop.	
	
	
:: 7) ENABLEEXTENSIONS / DISABLEEXTENSIONS behavior

	:: Command extensions add features 
	(like delayed expansion, setlocal, for /f enhancements, if exist behavior, call behavior improvements).

	:: SETLOCAL ENABLEEXTENSIONS forces extensions on for the block—
	:: useful if running under /E:OFF or on systems with extensions disabled. 
	
	:: Similarly DISABLEEXTENSIONS will turn them off inside the block.

	:: Use only if you need deterministic behavior; 
	:: otherwise rely on default (extensions are usually enabled).

:: 8) Interplay with CALL, GOTO, EXIT /B

	:: CALL creates a new call frame and 
	:: any SETLOCAL inside that CALL are popped when the called batch file returns (or when ENDLOCAL runs).

	:: EXIT /B returns from a batch file (if called from a called batch file). 
	:: If you EXIT /B while inside nested SETLOCAL, the implied ENDLOCAL runs for outstanding SETLOCALs — 
	:: so environment is restored.

	:: GOTO doesn’t affect SETLOCAL on its own; it just moves control inside the same frame.	
	
	
:: 9) Common patterns and useful examples	
	
	:: Pattern A — Local temporary variables
	:: Example:
	
		@echo off
		SETLOCAL
		set "TEMPVAR=42"
		:: do stuff using %TEMPVAR% (or !TEMPVAR! if inside loops)
		ENDLOCAL
		:: TEMPVAR not visible here
	
	:: Pattern B — Force delayed expansion temporarily
	:: Example:	
	
		@echo off
		SETLOCAL ENABLEDELAYEDEXPANSION
		:: code needing !VAR!
		ENDLOCAL	
	
	:: Pattern C — Get inner value out reliably:	
	:: Example:	
	
		@echo off
		SETLOCAL ENABLEDELAYEDEXPANSION
		set "LOCALVAR=I contain ^& special chars!"
		ENDLOCAL & call set "OUT=%%LOCALVAR%%"
		echo OUT=%OUT%	
	
	:: Pattern D — Detect extensions availability (compat legacy)	
	:: Example:
	
		@echo off
		VERIFY OTHER 2>nul
		SETLOCAL ENABLEEXTENSIONS
		IF ERRORLEVEL 1 echo Extensions not available
		ENDLOCAL
	
	
:: 10) Pitfalls you will run into — and how to avoid them

	:: Expecting percent expansion after ENDLOCAL: don't. Use CALL or FOR workaround.

	:: Using ENDLOCAL & set OUT=%LOCAL% hoping sequential parse will pick new value: wrong — parse happens first. 
	:: Use the call trick.

	:: Assuming delayed expansion always available: not necessarily on super-old or restricted environments — 
	:: but on modern Windows it's usually available.

	:: Special chars in values ( &, |, ^, > ): 
	:: these need escaping or use the for /f or temp file method to safely pass values out.

	:: Multiline values: batch is poor at preserving newlines in variables — 
	:: use files if you need multiline content.

:: 11) Performance & complexity considerations

	:: SETLOCAL/ENDLOCAL are cheap. Nesting a few is fine. 
	:: But extremely deep nesting repeated in loops is unnecessary complexity — 
	:: prefer clear single blocks.

	:: Using CALL for deferred expansion is convenient but CALL is slower than native set. 
	:: Use it only where needed.

:: 12) Quick reference: what to use when

	:: Temporary variables only inside script → 
	:: use SETLOCAL and ENDLOCAL.

	:: Need delayed expansion inside block → 
	:: SETLOCAL ENABLEDELAYEDEXPANSION.

	:: Need to propagate one variable out of block → 
	:: ENDLOCAL & call set "OUT=%%VAR%%".

	:: Values contain complicated characters → 
	:: prefer the for /f or temp file approach.

	:: Need to programmatically detect extensions → 
	:: use the VERIFY + SETLOCAL ENABLEEXTENSIONS trick (legacy).	
	
:: 13) Example complete script (practical)
	Example:
	
		@echo off
		:: Example: compute a value locally, pass it out reliably.

		echo outer before=%OUTER%
		set "OUTER=orig"

		SETLOCAL ENABLEDELAYEDEXPANSION
		:: compute stuff with delayed expansion
		set "INNER=Hello & world"
		:: push value out using call trick:
		ENDLOCAL & call set "OUTER=%%INNER%%"

		echo outer after=%OUTER%

	Expected output:
		outer before=orig
		outer after=Hello & world

:: 14) Final recommendations — practical rules to follow

:: Use SETLOCAL at the top of any script that modifies env vars to avoid leaks.

:: Use SETLOCAL ENABLEDELAYEDEXPANSION if you do looped/conditional variable updates.

:: When you must return a value to the caller, use the ENDLOCAL & call set "VAR=%%LOCALVAR%%" idiom.

:: For complex data, use temporary files. 
:: Don’t force batch to do what a small Python/PowerShell helper would do better.

:: Keep SETLOCAL/ENDLOCAL pairs readable and not deeply scattered — readability matters.


************************************************************************************************************
cmd help : setlocal /?
Begins localization of environment changes in a batch file.  Environment
changes made after SETLOCAL has been issued are local to the batch file.
ENDLOCAL must be issued to restore the previous settings.  When the end
of a batch script is reached, an implied ENDLOCAL is executed for any
outstanding SETLOCAL commands issued by that batch script.

SETLOCAL

If Command Extensions are enabled SETLOCAL changes as follows:

SETLOCAL batch command now accepts optional arguments:
        ENABLEEXTENSIONS / DISABLEEXTENSIONS
            enable or disable command processor extensions. These
            arguments takes precedence over the CMD /E:ON or /E:OFF
            switches. See CMD /? for details.
        ENABLEDELAYEDEXPANSION / DISABLEDELAYEDEXPANSION
            enable or disable delayed environment variable
            expansion. These arguments takes precedence over the CMD
            /V:ON or /V:OFF switches. See CMD /? for details.
These modifications last until the matching ENDLOCAL command,
regardless of their setting prior to the SETLOCAL command.

The SETLOCAL command will set the ERRORLEVEL value if given
an argument.  It will be zero if one of the two valid arguments
is given and one otherwise.  You can use this in batch scripts
to determine if the extensions are available, using the following
technique:

    VERIFY OTHER 2>nul
    SETLOCAL ENABLEEXTENSIONS
    IF ERRORLEVEL 1 echo Unable to enable extensions

This works because on old versions of CMD.EXE, SETLOCAL does NOT
set the ERRORLEVEL value. The VERIFY command with a bad argument
initializes the ERRORLEVEL value to a non-zero value.